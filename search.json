[
  {
    "objectID": "blog_listing.html",
    "href": "blog_listing.html",
    "title": "Blog",
    "section": "",
    "text": "Correlation vs linear regression\n\n\n\n\n\n\n\nRegression\n\n\nCorrelation\n\n\nApp\n\n\n\n\nInteractively compare and contrast correlation and regression for simple linear models.\n\n\n\n\n\n\nDec 24, 2024\n\n\nAlasdair Warwick\n\n\n\n\n\n\n\n\nInteractive Exploration of Diagnostic Testing\n\n\nSensitivity, specificity, postive and negative predictive values\n\n\n\n\nPositive predictive value\n\n\nApp\n\n\n\n\nUnderstanding how disease prevalence and test characteristics affect diagnostic test performance is crucial in clinical practice. This interactive visualisation demonstrates these relationships using a population of 100 individuals.\n\n\n\n\n\n\nDec 29, 2024\n\n\nAlasdair Warwick\n\n\n\n\n\n\n\n\nSampling Variation and Standard Error\n\n\nUnderstanding Statistical Uncertainty Through Interactive Visualization\n\n\n\n\nConfidence intervals\n\n\nStandard error\n\n\nApp\n\n\n\n\nExplore how sample size affects sampling distribution using simulated samples of 100 individuals.\n\n\n\n\n\n\nDec 31, 2024\n\n\nAlasdair Warwick\n\n\n\n\n\n\n\n\nA Comprehensive Statistics Primer\n\n\nAn Introduction to Fundamental Statistical Concepts\n\n\n\n\nProbability\n\n\nStart here\n\n\nSlides\n\n\n\n\nThis primer covers essential statistical concepts including probability, distributions, hypothesis testing, and regression analysis.\n\n\n\n\n\n\nJan 2, 2025\n\n\nAlasdair Warwick\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/ppv.html",
    "href": "blog/ppv.html",
    "title": "Interactive Exploration of Diagnostic Testing",
    "section": "",
    "text": "Understanding how disease prevalence and test characteristics affect diagnostic test performance is crucial in clinical practice. This interactive visualisation demonstrates these relationships using a population of 100 individuals.\n\n\nCode\nviewof prevalence = Inputs.range([1, 50], {\n  label: \"Disease Prevalence (%)\",\n  step: 1,\n  value: 10\n})\n\nviewof sensitivity = Inputs.range([50, 100], {\n  label: \"Test Sensitivity (%)\",\n  step: 1,\n  value: 80\n})\n\nviewof specificity = Inputs.range([50, 100], {\n  label: \"Test Specificity (%)\",\n  step: 1,\n  value: 90\n})\n\n// Reactive calculation\ngrid = {\n  const totalDots = 100;\n  const diseaseCount = Math.round(totalDots * (prevalence / 100));\n  \n  const expectedTruePositives = Math.round(diseaseCount * (sensitivity / 100));\n  const expectedFalsePositives = Math.round((totalDots - diseaseCount) * ((100 - specificity) / 100));\n  \n  const dots = Array(totalDots).fill(null).map((_, index) => ({\n    hasDisease: index < diseaseCount,\n    testPositive: index < (expectedTruePositives + expectedFalsePositives)\n  }));\n  \n  // Calculate statistics\n  const truePositives = dots.filter(d => d.hasDisease && d.testPositive).length;\n  const falsePositives = dots.filter(d => !d.hasDisease && d.testPositive).length;\n  const trueNegatives = dots.filter(d => !d.hasDisease && !d.testPositive).length;\n  const falseNegatives = dots.filter(d => d.hasDisease && !d.testPositive).length;\n\n  const ppv = (truePositives / (truePositives + falsePositives)) * 100;\n  const npv = (trueNegatives / (trueNegatives + falseNegatives)) * 100;\n  const LRplus = (sensitivity / (100 - specificity));\n  const LRminus = ((100 - sensitivity) / specificity);\n\n  return {\n    dots: dots.sort((a, b) => (b.hasDisease * 2 + b.testPositive) - (a.hasDisease * 2 + a.testPositive)),\n    stats: { truePositives, falsePositives, trueNegatives, falseNegatives, ppv, npv, LRplus, LRminus }\n  };\n}\n\n// Display output\ndisplay = html`\n<div class=\"p-4 bg-white rounded-lg shadow\">\n  <div class=\"grid grid-cols-10 gap-1 p-4 bg-gray-100 rounded\">\n    ${grid.dots.map(dot => `\n      <div class=\"w-6 h-6 rounded-full ${dot.hasDisease ? 'bg-red-500' : 'bg-green-400'} \n           ${dot.testPositive ? 'border-2 border-blue-500' : 'border border-transparent'}\">\n      </div>\n    `).join('')}\n  </div>\n  \n  <div class=\"grid grid-cols-2 gap-4 mt-4 p-4 bg-gray-100 rounded\">\n    <div>\n      <p class=\"font-medium\">Test Results:</p>\n      <p>True Positives: ${grid.stats.truePositives}</p>\n      <p>False Positives: ${grid.stats.falsePositives}</p>\n      <p>True Negatives: ${grid.stats.trueNegatives}</p>\n      <p>False Negatives: ${grid.stats.falseNegatives}</p>\n    </div>\n    <div>\n      <p class=\"font-medium\">Predictive Values:</p>\n      <p class=\"font-bold\">PPV: ${grid.stats.ppv.toFixed(1)}%</p>\n      <p class=\"font-bold\">NPV: ${grid.stats.npv.toFixed(1)}%</p>\n      <p class=\"font-medium mt-4\">Likelihood Ratios:</p>\n      <p>LR+ = ${grid.stats.LRplus.toFixed(2)}</p>\n      <p>LR- = ${grid.stats.LRminus.toFixed(2)}</p>\n    </div>\n  </div>\n</div>\n`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisease Prevalence: Adjust this slider to see how the proportion of diseased individuals in the population affects test performance.\nTest Sensitivity: This represents the test’s ability to correctly identify diseased individuals.\nTest Specificity: This shows the test’s ability to correctly identify healthy individuals.\n\n\n\n\n\nEach dot represents one individual in the population\nRed dots: Individuals with disease\nGreen dots: Healthy individuals\nBlue border: Positive test result\nNo border: Negative test result"
  },
  {
    "objectID": "blog/stats_primer.html",
    "href": "blog/stats_primer.html",
    "title": "A Comprehensive Statistics Primer",
    "section": "",
    "text": "⁠Single sample: probability basics - normal distribution and binomial (coins)\n⁠⁠2 samples: normal and chi square\nAdjusting for confounders - (stratifying) & linear regression. Logistic regression"
  },
  {
    "objectID": "blog/stats_primer.html#coin-flip-simulation",
    "href": "blog/stats_primer.html#coin-flip-simulation",
    "title": "A Comprehensive Statistics Primer",
    "section": "Coin Flip Simulation",
    "text": "Coin Flip Simulation\nThis simulation demonstrates the binomial distribution through repeated coin flips."
  },
  {
    "objectID": "blog/stats_primer.html#next-slides",
    "href": "blog/stats_primer.html#next-slides",
    "title": "A Comprehensive Statistics Primer",
    "section": "Next slides",
    "text": "Next slides\n\n\nCode\nprint(\"Hi\")\n\n\nHi"
  },
  {
    "objectID": "blog/sampling_variation_se.html",
    "href": "blog/sampling_variation_se.html",
    "title": "Sampling Variation and Standard Error",
    "section": "",
    "text": "This interactive visualization allows you to explore how sample size affects the sampling distribution and the calculation of confidence intervals (CI). Adjust the sample size and confidence level, then take samples to see the results.\n\n\nCode\nCONFIDENCE_LEVELS = ({\n  60: 0.841,\n  70: 1.036,\n  80: 1.28,\n  85: 1.44,\n  90: 1.645,\n  95: 1.96,\n  99: 2.576,\n  99.9: 3.291\n})\n\n// Create inputs\nviewof sampleSize = Inputs.range([10, 1000], {\n  step: 10, \n  value: 10, \n  label: \"Sample Size\"\n})\n\n// Create radio buttons for confidence level\nviewof confidenceLevel = Inputs.radio(\n  Object.keys(CONFIDENCE_LEVELS).map(Number).sort((a,b) => a-b),\n  {\n    value: 95,\n    label: \"Confidence Level\",\n    format: x => x + \"%\"\n  }\n)\n\nviewof takeSamples = Inputs.button(\"Take 100 Samples\")\n\n// Generate initial population\npopulation = {\n  const size = 10000;\n  const mean = 120;\n  const std = 10;\n  \n  return Array.from({length: size}, () => {\n    let u1, u2;\n    do {\n      u1 = Math.random();\n      u2 = Math.random();\n    } while (u1 === 0);\n    \n    const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n    return Math.round(mean + z * std);\n  });\n}\n\n// Calculate population statistics\npopulationStats = {\n  const mean = population.reduce((a, b) => a + b, 0) / population.length;\n  const squaredDiffs = population.map(x => Math.pow(x - mean, 2));\n  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / population.length;\n  const std = Math.sqrt(variance);\n  \n  return {mean, std};\n}\n\n// Create population histogram\npopulationPlot = Plot.plot({\n  width: 600,\n  height: 300,\n  grid: true,\n  x: {\n    label: \"Blood Pressure (mmHg)\",\n    domain: [80, 160],\n    ticks: d3.range(80, 161, 5)\n  },\n  y: {label: \"Count\"},\n  marks: [\n    Plot.rectY(\n      d3.bin()\n        .domain([80, 160])\n        .thresholds(40)\n        (population),\n      {x1: \"x0\", x2: \"x1\", y: \"length\", fill: \"#8884d8\"}\n    ),\n    Plot.ruleY([0]),\n    Plot.ruleX([populationStats.mean], {stroke: \"red\", strokeWidth: 2})\n  ],\n  title: \"Population Distribution (N=10,000)\"\n})\n\n// Initialize mutable state\ninitialSampleMeans = []\nmutable sampleMeans = initialSampleMeans\n\n// Sampling handler cell\nhandleSampling = {\n  takeSamples; // React to button clicks\n  \n  const newMeans = Array.from({length: 100}, () => {\n    const sample = Array.from({length: sampleSize}, () => \n      population[Math.floor(Math.random() * population.length)]\n    );\n    return sample.reduce((a, b) => a + b, 0) / sample.length;\n  });\n  \n  mutable sampleMeans = newMeans;\n  return md`*Generated ${newMeans.length} new sample means*`\n}\n\n// Calculate confidence interval\nciStats = {\n  if (sampleMeans.length === 0) return null;\n  \n  const standardError = populationStats.std / Math.sqrt(sampleSize);\n  const zScore = CONFIDENCE_LEVELS[confidenceLevel];\n  const ciWidth = zScore * standardError;\n  const ciLower = populationStats.mean - ciWidth;\n  const ciUpper = populationStats.mean + ciWidth;\n  const outsideCI = sampleMeans.filter(\n    mean => mean < ciLower || mean > ciUpper\n  ).length;\n  \n  return {\n    standardError,\n    ciLower,\n    ciUpper,\n    outsideCI\n  };\n}\n\n// Create sample means histogram\nsamplingPlot = {\n  if (sampleMeans.length === 0) return null;\n  \n  return Plot.plot({\n    width: 600,\n    height: 300,\n    grid: true,\n    x: {\n      label: \"Sample Mean Blood Pressure (mmHg)\",\n      domain: [80, 160],\n      ticks: d3.range(80, 161, 5)\n    },\n    y: {label: \"Count\"},\n    marks: [\n      Plot.rectY(\n        d3.bin()\n          .domain([80, 160])\n          .thresholds(40)\n          (sampleMeans),\n        {x1: \"x0\", x2: \"x1\", y: \"length\", fill: \"#82ca9d\"}\n      ),\n      Plot.ruleY([0]),\n      Plot.ruleX([populationStats.mean], {stroke: \"red\", strokeWidth: 2}),\n      Plot.ruleX([ciStats.ciLower], {stroke: \"blue\", strokeDasharray: \"3,3\"}),\n      Plot.ruleX([ciStats.ciUpper], {stroke: \"blue\", strokeDasharray: \"3,3\"})\n    ],\n    title: `Distribution of Sample Means (n=${sampleSize})`\n  });\n}\n\n// Display statistics\npopulation_statistics = {\n  const population_stats = html`<div style=\"font-size: 14px; color: #666;\">\n    <p>Population Mean: ${populationStats.mean.toFixed(1)} mmHg</p>\n    <p>Population Standard Deviation: ${populationStats.std.toFixed(1)} mmHg</p>\n  </div>`;\n  return population_stats;\n}\n\nsample_statistics = {\n const sample_stats = html`<div style=\"font-size: 14px; color: #666;\">\n    ${ciStats ? html`\n      <p>${confidenceLevel}% Confidence Interval: ${ciStats.ciLower.toFixed(1)} - ${ciStats.ciUpper.toFixed(1)} mmHg</p>\n      <p>Number of samples outside CI: ${ciStats.outsideCI} out of 100</p>\n      <p>Standard Error: ${ciStats.standardError.toFixed(2)} mmHg</p>\n    ` : ''}\n  </div>`;\n  return sample_stats; \n}\n\n// Layout everything\nhtml`<div style=\"font-family: system-ui, sans-serif;\">\n  ${populationPlot}\n  ${population_statistics}\n  <div style=\"margin: 1rem 0;\">\n    ${viewof sampleSize}\n    ${viewof confidenceLevel}\n    ${viewof takeSamples}\n  </div>\n  ${handleSampling}\n  ${samplingPlot}\n  ${sample_statistics}\n</div>`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdjust the sample size and confidence level using the provided controls. Click the “Take 100 Samples” button to generate new sample means and visualize the results.\n\n\n\nThe population distribution and sample means distribution are displayed as histograms. The red line represents the population mean, and the blue dashed lines represent the confidence interval.\n\nPopulation Mean: The average value of the entire population.\nSample Mean: The average value of a sample taken from the population.\nStandard Error: The standard deviation of the sample means, indicating the variability of the sample means.\nConfidence Interval: A range of values that is likely to contain the population mean with a certain level of confidence."
  },
  {
    "objectID": "blog/correlation_regression.html",
    "href": "blog/correlation_regression.html",
    "title": "Correlation vs linear regression",
    "section": "",
    "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n# #| components: [viewer, editor]\n# #| layout: vertical\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport statsmodels.api as sm\nfrom scipy import stats\nfrom shiny import App, render, ui, reactive\n\n# Define the UI\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_slider(\"slope\", \"Slope (β):\", -5.0, 5.0, 1.0, step=0.1),\n        ui.input_slider(\"intercept\", \"Intercept (c):\", -10, 10, 0, step=1),\n        ui.input_slider(\"noise\", \"Noise Level:\", 0, 50, 1, step=0.1),\n        ui.input_slider(\"n_points\", \"Number of Points:\", 10, 500, 100, step=10),\n        ui.input_checkbox(\"fix_scale\", \"Fix Axis Scale\", True)\n    ),\n    ui.row(\n        ui.column(\n            6,\n            ui.output_plot(\"scatter_plot\"),\n            ui.output_text(\"correlation_output\"),\n            ui.output_text(\"regression_output\")\n        ),\n        ui.column(\n            6,\n            ui.output_code(\"regression_summary\")\n            )\n    )\n)\n\n# Define the server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def generate_data():\n        np.random.seed(42)  # For reproducibility\n        x = np.linspace(-10, 10, input.n_points())\n        noise = np.random.normal(0, input.noise(), len(x))\n        y = input.slope() * x + input.intercept() + noise\n        return pd.DataFrame({\"x\": x, \"y\": y})\n\n    @output\n    @render.plot\n    def scatter_plot():\n        data = generate_data()\n        x, y = data[\"x\"], data[\"y\"]\n        max_val = max(abs(x).max(), abs(y).max())\n        plt.figure()\n        plt.scatter(x, y)\n        plt.axhline(0, color='black', linewidth=1)\n        plt.axvline(0, color='black', linewidth=1)\n        plt.xlabel(\"X\")\n        plt.ylabel(\"Y\")\n        plt.title(\"Scatter Plot\")\n        plt.grid(True)\n        if input.fix_scale():\n            plt.xlim(-max_val, max_val)\n            plt.ylim(-max_val, max_val)\n        plt.gca().set_aspect('equal', adjustable='box')\n        return plt.gcf()\n\n    @output\n    @render.text\n    def correlation_output():\n        data = generate_data()\n        correlation, p_value = stats.pearsonr(data[\"x\"], data[\"y\"])\n        return f\"Correlation: {correlation:.2f}, p-value: {p_value:.2e}\"\n\n    @output\n    @render.text\n    def regression_output():\n        data = generate_data()\n        x = sm.add_constant(data[\"x\"])  # Adds a constant term to the predictor\n        model = sm.OLS(data[\"y\"], x).fit()\n        summary = model.summary2().tables[1]\n        slope_p_value = summary.loc[\"x\", \"P>|t|\"]\n        intercept_p_value = summary.loc[\"const\", \"P>|t|\"]\n        return (\n            f\"Regression Line: y = {model.params['x']:.2f}x + {model.params['const']:.2f}\\n\"\n            f\"R-squared: {model.rsquared:.2f}\\n\"\n            f\"Slope p-value: {slope_p_value:.2e}\\n\"\n            f\"Intercept p-value: {intercept_p_value:.2e}\\n\"\n            f\"Standard Error: {model.bse['x']:.2f}\"\n        )\n\n    @output\n    @render.code\n    def regression_summary():\n        data = generate_data()\n        x = sm.add_constant(data[\"x\"])  # Adds a constant term to the predictor\n        model = sm.OLS(data[\"y\"], x).fit()\n        return model.summary()\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the Statistics Foundations project! This repository contains resources, code, and documentation for understanding fundamental concepts in statistics.\nThis project aims to provide a comprehensive guide to foundational statistical concepts through interactive visualizations and practical examples. It is designed for students, educators, and professionals who want to deepen their understanding of statistics."
  },
  {
    "objectID": "index.html#example-app",
    "href": "index.html#example-app",
    "title": "Welcome",
    "section": "Example app",
    "text": "Example app\nThis is a simple Shinylive application embedded in a Quarto doc.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n\nfrom shiny import *\n\napp_ui = ui.page_fluid(\n    ui.input_slider(\"n\", \"N\", 0, 100, 40),\n    ui.output_text_verbatim(\"txt\"),\n)\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        return f\"The value of n*2 is {input.n() * 2}\"\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "version.html",
    "href": "version.html",
    "title": "Statistics Foundations",
    "section": "",
    "text": "0.0.0.9000"
  }
]